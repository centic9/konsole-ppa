From: Kurt Hindenburg <kurt.hindenburg@gmail.com>
Date: Sun, 4 Feb 2018 14:09:28 -0500
Subject: Add support for ECMA-48 REP: repeating previous character

Patch by btown using lxde/qtermwidget@60221da by @yan12125

ECMA-48 8.3.103 describes the sequence CSI Pn b for repeating the
previous character in the data stream. This sequence has been present
in XTerm since January 1997 and has been added to the latest terminfo
entry for xterm-new and derived entries such as xterm-256color.

https://phabricator.kde.org/D10064
---
 src/Screen.cpp         | 23 ++++++++++++++++++++++-
 src/Screen.h           |  8 ++++++++
 src/Vt102Emulation.cpp |  3 ++-
 3 files changed, 32 insertions(+), 2 deletions(-)

diff --git a/src/Screen.cpp b/src/Screen.cpp
index 8c1bc70..64d1e6d 100644
--- a/src/Screen.cpp
+++ b/src/Screen.cpp
@@ -73,7 +73,8 @@ Screen::Screen(int lines, int columns):
     _effectiveForeground(CharacterColor()),
     _effectiveBackground(CharacterColor()),
     _effectiveRendition(DEFAULT_RENDITION),
-    _lastPos(-1)
+    _lastPos(-1),
+    _lastDrawnChar(0)
 {
     _lineProperties.resize(_lines + 1);
     for (int i = 0; i < _lines + 1; i++)
@@ -223,6 +224,24 @@ void Screen::insertChars(int n)
         _screenLines[_cuY].resize(_columns);
 }
 
+void Screen::repeatChars(int n)
+{
+    if (n == 0) {
+        n = 1; // Default
+    }
+
+    // From ECMA-48 version 5, section 8.3.103:
+    // "If the character preceding REP is a control function or part of a
+    // control function, the effect of REP is not defined by this Standard."
+    //
+    // So, a "normal" program should always use REP immediately after a visible
+    // character (those other than escape sequences). So, _lastDrawnChar can be
+    // safely used.
+    for (int i = 0; i < n; i++) {
+        displayCharacter(_lastDrawnChar);
+    }
+}
+
 void Screen::deleteLines(int n)
 {
     if (n == 0) n = 1; // Default
@@ -695,6 +714,8 @@ void Screen::displayCharacter(unsigned short c)
     currentChar.rendition = _effectiveRendition;
     currentChar.isRealCharacter = true;
 
+    _lastDrawnChar = c;
+
     int i = 0;
     const int newCursorX = _cuX + w--;
     while (w != 0) {
diff --git a/src/Screen.h b/src/Screen.h
index e7aebcf..f1f0fb7 100644
--- a/src/Screen.h
+++ b/src/Screen.h
@@ -202,6 +202,11 @@ public:
      * If @p n is 0 then one character is inserted.
      */
     void insertChars(int n);
+    /**
+     * Repeat the preceeding graphic character @n times, including SPACE.
+     * If @n is 0 then the character is repeated once.
+     */
+    void repeatChars(int n);
     /**
      * Removes @p n lines beginning from the current cursor position.
      * The position of the cursor is not altered.
@@ -714,6 +719,9 @@ private:
 
     // last position where we added a character
     int _lastPos;
+
+    // used in REP (repeating char)
+    unsigned short _lastDrawnChar;
 };
 }
 
diff --git a/src/Vt102Emulation.cpp b/src/Vt102Emulation.cpp
index d8b1dfb..b156462 100644
--- a/src/Vt102Emulation.cpp
+++ b/src/Vt102Emulation.cpp
@@ -240,7 +240,7 @@ void Vt102Emulation::initTokenizer()
     for (i = 32; i < 256; ++i) {
         charClass[i] |= CHR;
     }
-    for (s = (quint8 *)"@ABCDGHILMPSTXZcdfry"; *s != 0u; ++s) {
+    for (s = (quint8 *)"@ABCDGHILMPSTXZbcdfry"; *s != 0u; ++s) {
         charClass[*s] |= CPN;
     }
     // resize = \e[8;<row>;<col>t
@@ -680,6 +680,7 @@ void Vt102Emulation::processToken(int token, int p, int q)
     case TY_CSI_PN('T'      ) : _currentScreen->scrollDown           (p         ); break;
     case TY_CSI_PN('X'      ) : _currentScreen->eraseChars           (p         ); break;
     case TY_CSI_PN('Z'      ) : _currentScreen->backtab              (p         ); break;
+    case TY_CSI_PN('b'      ) : _currentScreen->repeatChars          (p         ); break;
     case TY_CSI_PN('c'      ) :      reportTerminalType   (          ); break; //VT100
     case TY_CSI_PN('d'      ) : _currentScreen->setCursorY           (p         ); break; //LINUX
     case TY_CSI_PN('f'      ) : _currentScreen->setCursorYX          (p,      q); break; //VT100
